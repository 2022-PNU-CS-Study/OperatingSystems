# 스케쥴링
- CPU의 시간을 나누어써서 가상화
- 스케줄링의 고려사항
  - 성능저하: 오버헤드를 최소화
  - 제어문제: 통제를 유지하면서 효율적으로 프로세스 실행
# 제한적 직접 실행원리(Limited Direct Execution)
프로세스가 cpu에 제한없이 직접 실행되면 프로세스는 원치않는 기능을 실행하거나 cpu를 독점하는 경우가 발생할 수 있다. 이러한 문제점을 해결하고자 직접 실행방식에 제한을 걸어주게 되었다.
## 권한 분리
프로세스가 무분별하게 자원에 접근하는 것을 막기위해서 커널모드와 사용자 모드를 사용하워 권한을 분리해준다.
- 사용자 모드(User mode): 접근할 수 있는 자원이 제한된 모드
- 커널 모드(Kernel mode): 모든 자원에 접근 가능한 모드
- trap: 사용자 모드에서 trap 시스템 콜을 사용하여 커널 모드의 기능을 사용할 수 있다.
- return-from-trap: trap을 사용한 명령이 완료되면 호출한 사용자 프로그램으로 돌아간다.
- 커널 스택(kernel stack): 프로그램 카운터, 플래그, 레지스터들을 각 프로세스의 커널스택에 저장하여 보관. return-from-trap 명령어가 커널 스택에서 값을 가져와서 사용자 프로그램의 다시 실행.
- 트랩 테이블(trap table): 트랩이 사용될 때 cpu가 점프하여 사용해야할 trap 명령어의 위치 저장
- 트랩 핸들러(grap handler): 트랩을 처리

![제한적 직접 실행 프로토콜](./aseet/제한적%20직접%20실행%20프로토콜-진호.jpeg)
### trap 과정
1. 사용자 모드에서 trap 호출
2. 레지스터를 커널 스택에 저장
3. 하드웨어에서 트랩 테이블의 트랩 위치를 보고 트랩 핸들러로 분기
4. 커널 모드에서 트랩 처리
5. return-from-trap
6. 하드웨어가 커널 스택에서 데이터 복구
7. 사용자 모드로 전환

## 프로스세스 전환
### 협조(cooperative)
- 운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰
- 너무 오랫동안 실행할 가능성이 있는 프로세스는 주기적으로 cpu를 포기하여 운영체제가 다른 작업을 실핼할 수 있다고 가정
- 프로세스는 **yield** 시스템 콜을 사용하여 운영체제에게 제어를 넘긴다.
- 악의적으로 만든 프로그램이거나 버그로 인해서 무한 루프에 빠질 경우 제어를 넘길 수 없다.
### 비협조
비협조적인 프로세스로부터 제어를 얻기위해서 **<u>타이머 인터럽트(timer interrupt)</u>** 사용
- 타이머 인터럽트: 수 밀리초 마다 인터럽트를 발생시켜 <u>인터럽트 핸들러(interrupt handler)</u>를 실행시킴
### 문맥의 저장과 복원
- <u>**스케줄러(scheduler)**</u>: 프로세스 전환을 위해 실해중인 프로세스를 중지시키면 해당 프로세스를 실행할 것인지 전환할 것인지 결정을 내리는 역할을 한다.
- **문맥 교환(Context Switching)**: 프로세스를 전환할 때 실행중인 프로세스의 레지스터 값을 저장하고 실핼할 프로세스의 레지스터값을 가져온다. return-from-trap이 실행될 때 다른 프로세스의 값을 가져와서 사용함으로써 문맥교환 가능.
  
![timer interrupt](aseet/타이머%20인터럽트-진호.jpeg)